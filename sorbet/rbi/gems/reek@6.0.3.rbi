# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `reek` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Reek
end

module Reek::AST
end

class Reek::AST::ASTNodeClassMap
  def initialize; end

  def extension_map; end
  def klass_for(type); end

  private

  def klass_map; end
end

class Reek::AST::Builder < ::Parser::Builders::Default
  def string_value(token); end
end

class Reek::AST::Node < ::Parser::AST::Node
  def initialize(type, children = T.unsafe(nil), options = T.unsafe(nil)); end

  def condition; end
  def contains_nested_node?(target_type); end
  def each_node(target_types, ignoring = T.unsafe(nil), &blk); end
  def format_to_ruby; end
  def full_comment; end
  def leading_comment; end
  def length; end
  def line; end
  def name; end
  def source; end
  def statements; end

  protected

  def look_for(target_types, ignoring, &blk); end
  def look_for_recurse(target_types, ignoring, &blk); end

  private

  def comments; end
  def each_sexp; end
end

class Reek::AST::ObjectRefs
  def initialize; end

  def most_popular; end
  def record_reference(name:, line: T.unsafe(nil)); end
  def references_to(name); end
  def self_is_max?; end

  private

  def refs; end
end

class Reek::AST::ReferenceCollector
  def initialize(ast); end

  def num_refs_to_self; end

  private

  def ast; end
  def explicit_self_calls; end
  def implicit_self_calls; end
end

module Reek::AST::SexpExtensions
end

module Reek::AST::SexpExtensions::AndNode
  include(::Reek::AST::SexpExtensions::LogicOperatorBase)
end

module Reek::AST::SexpExtensions::ArgNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)
end

module Reek::AST::SexpExtensions::ArgNodeBase
  def anonymous_splat?; end
  def block?; end
  def components; end
  def marked_unused?; end
  def name; end
  def optional_argument?; end
  def plain_name; end
end

module Reek::AST::SexpExtensions::ArgsNode
  include(::Reek::AST::SexpExtensions::NestedAssignables)
end

module Reek::AST::SexpExtensions::BeginNode
  def statements; end
end

module Reek::AST::SexpExtensions::BlockNode
  def args; end
  def block; end
  def call; end
  def parameter_names; end
  def parameters; end
  def simple_name; end
  def without_block_arguments?; end
end

module Reek::AST::SexpExtensions::BlockargNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)

  def block?; end
end

Reek::AST::SexpExtensions::CSendNode = Reek::AST::SexpExtensions::SendNode

module Reek::AST::SexpExtensions::CaseNode
  def body_nodes(type, ignoring = T.unsafe(nil)); end
  def condition; end
  def else_body; end
end

module Reek::AST::SexpExtensions::CasgnNode
  include(::Reek::AST::SexpExtensions::ConstantDefiningNodeBase)

  def defines_module?; end
  def name; end
  def superclass; end
  def value; end

  private

  def constant_definition; end
end

module Reek::AST::SexpExtensions::ClassNode
  include(::Reek::AST::SexpExtensions::ConstantDefiningNodeBase)
  include(::Reek::AST::SexpExtensions::ModuleNodeBase)

  def superclass; end
end

module Reek::AST::SexpExtensions::ConstNode
  def name; end
  def namespace; end
  def simple_name; end
end

module Reek::AST::SexpExtensions::ConstantDefiningNodeBase
  def full_name(outer); end
  def simple_name; end
end

module Reek::AST::SexpExtensions::CvarNode
  include(::Reek::AST::SexpExtensions::VariableBase)
end

Reek::AST::SexpExtensions::CvasgnNode = Reek::AST::SexpExtensions::CvarNode

Reek::AST::SexpExtensions::CvdeclNode = Reek::AST::SexpExtensions::CvarNode

module Reek::AST::SexpExtensions::DefNode
  include(::Reek::AST::SexpExtensions::MethodNodeBase)

  def argslist; end
  def body; end
  def depends_on_instance?; end
  def full_name(outer); end
  def name; end
end

module Reek::AST::SexpExtensions::DefsNode
  include(::Reek::AST::SexpExtensions::MethodNodeBase)

  def argslist; end
  def body; end
  def depends_on_instance?; end
  def full_name(outer); end
  def name; end
  def receiver; end
end

module Reek::AST::SexpExtensions::Forward_ArgsNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)

  def anonymous_splat?; end
end

module Reek::AST::SexpExtensions::GvarNode
  include(::Reek::AST::SexpExtensions::VariableBase)
end

module Reek::AST::SexpExtensions::IfNode
  def body_nodes(type, ignoring = T.unsafe(nil)); end
  def condition; end
end

module Reek::AST::SexpExtensions::IvarNode
  include(::Reek::AST::SexpExtensions::VariableBase)
end

module Reek::AST::SexpExtensions::IvasgnNode
  include(::Reek::AST::SexpExtensions::VariableBase)
end

module Reek::AST::SexpExtensions::KwargNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)
end

module Reek::AST::SexpExtensions::KwoptargNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)

  def optional_argument?; end
end

module Reek::AST::SexpExtensions::KwrestargNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)

  def anonymous_splat?; end
end

module Reek::AST::SexpExtensions::LambdaNode
  def name; end
end

module Reek::AST::SexpExtensions::LogicOperatorBase
  def body_nodes(type, ignoring = T.unsafe(nil)); end
  def condition; end
end

module Reek::AST::SexpExtensions::LvarNode
  include(::Reek::AST::SexpExtensions::VariableBase)

  def var_name; end
end

Reek::AST::SexpExtensions::LvasgnNode = Reek::AST::SexpExtensions::LvarNode

module Reek::AST::SexpExtensions::MethodNodeBase
  def arg_names; end
  def arguments; end
  def body_nodes(types, ignoring = T.unsafe(nil)); end
  def ends_with_bang?; end
  def name_without_bang; end
  def parameter_names; end
  def parameters; end
end

module Reek::AST::SexpExtensions::MlhsNode
  include(::Reek::AST::SexpExtensions::NestedAssignables)
end

module Reek::AST::SexpExtensions::ModuleNode
  include(::Reek::AST::SexpExtensions::ConstantDefiningNodeBase)
  include(::Reek::AST::SexpExtensions::ModuleNodeBase)
end

module Reek::AST::SexpExtensions::ModuleNodeBase
  include(::Reek::AST::SexpExtensions::ConstantDefiningNodeBase)

  def direct_children; end
  def name; end
end

module Reek::AST::SexpExtensions::NestedAssignables
  def components; end
end

Reek::AST::SexpExtensions::Op_AsgnNode = Reek::AST::SexpExtensions::SendNode

module Reek::AST::SexpExtensions::OptargNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)

  def optional_argument?; end
end

module Reek::AST::SexpExtensions::OrNode
  include(::Reek::AST::SexpExtensions::LogicOperatorBase)
end

module Reek::AST::SexpExtensions::RestargNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)

  def anonymous_splat?; end
end

module Reek::AST::SexpExtensions::SelfNode
  def name; end
end

module Reek::AST::SexpExtensions::SendNode
  def args; end
  def attr_with_writable_flag?; end
  def attribute_writer?; end
  def module_creation_call?; end
  def module_creation_receiver?; end
  def name; end
  def object_creation_call?; end
  def participants; end
  def receiver; end
end

Reek::AST::SexpExtensions::SendNode::ATTR_DEFN_METHODS = T.let(T.unsafe(nil), Array)

module Reek::AST::SexpExtensions::ShadowargNode
  include(::Reek::AST::SexpExtensions::ArgNodeBase)
end

module Reek::AST::SexpExtensions::SuperNode
  def name; end
end

module Reek::AST::SexpExtensions::SymNode
  def full_name(outer); end
  def name; end
end

module Reek::AST::SexpExtensions::VariableBase
  def name; end
end

module Reek::AST::SexpExtensions::WhenNode
  def body; end
  def condition_list; end
end

module Reek::AST::SexpExtensions::YieldNode
  def args; end
end

Reek::AST::SexpExtensions::ZsuperNode = Reek::AST::SexpExtensions::SuperNode

module Reek::CLI
end

module Reek::CLI::Silencer

  private

  def silently; end
  def without_warnings; end

  class << self
    def silently; end
    def without_warnings; end
  end
end

class Reek::CodeComment
  def initialize(comment:, line: T.unsafe(nil), source: T.unsafe(nil)); end

  def config; end
  def descriptive?; end

  private

  def escalate_legacy_separator(separator); end
  def line; end
  def original_comment; end
  def sanitized_comment; end
  def source; end
end

Reek::CodeComment::CONFIGURATION_REGEX = T.let(T.unsafe(nil), Regexp)

class Reek::CodeComment::CodeCommentValidator
  def initialize(detector_name:, original_comment:, line:, source:, options:); end

  def validate; end

  private

  def configuration_keys_difference; end
  def detector_class; end
  def detector_name; end
  def escalate_unknown_configuration_key; end
  def given_configuration_keys; end
  def given_keys_legit?; end
  def legacy_format?; end
  def line; end
  def options; end
  def original_comment; end
  def parsed_options; end
  def separator; end
  def source; end
  def valid_detector_keys; end
end

Reek::CodeComment::DISABLE_DETECTOR_CONFIGURATION = T.let(T.unsafe(nil), String)

Reek::CodeComment::MINIMUM_CONTENT_LENGTH = T.let(T.unsafe(nil), Integer)

Reek::CodeComment::SANITIZE_REGEX = T.let(T.unsafe(nil), Regexp)

module Reek::Configuration
end

class Reek::Configuration::AppConfiguration
  include(::Reek::Configuration::ConfigurationValidator)

  def initialize(values: T.unsafe(nil)); end

  def directive_for(source_via); end
  def load_values(values); end
  def path_excluded?(path); end

  private

  def default_directive; end
  def default_directive=(_arg0); end
  def directory_directives; end
  def directory_directives=(_arg0); end
  def excluded_paths; end
  def excluded_paths=(_arg0); end

  class << self
    def default; end
    def from_default_path; end
    def from_hash(hash); end
    def from_path(path); end
  end
end

class Reek::Configuration::ConfigurationConverter
  include(::Reek::Configuration::ConfigurationValidator)

  def initialize(configuration); end

  def configuration; end
  def convert; end

  private

  def convertible_attributes(detector_configuration); end
  def marked_as_regex?(value); end
  def strings_to_regexes_for_detectors; end
  def strings_to_regexes_for_directories; end
  def to_regex(value); end
end

Reek::Configuration::ConfigurationConverter::REGEXABLE_ATTRIBUTES = T.let(T.unsafe(nil), Array)

module Reek::Configuration::ConfigurationFileFinder
  extend(::Reek::Configuration::ConfigurationValidator)

  class << self
    def find(path: T.unsafe(nil), current: T.unsafe(nil), home: T.unsafe(nil)); end
    def find_and_load(path: T.unsafe(nil)); end
    def load_from_file(path); end

    private

    def find_by_dir(start); end
    def find_in_dir(dir); end
  end
end

Reek::Configuration::ConfigurationFileFinder::DEFAULT_FILE_NAME = T.let(T.unsafe(nil), String)

module Reek::Configuration::ConfigurationValidator

  private

  def key_to_smell_detector(key); end
  def smell_type?(key); end
  def with_valid_directory(path); end
end

module Reek::Configuration::DefaultDirective
  include(::Reek::Configuration::ConfigurationValidator)

  def add(detectors_configuration); end
end

module Reek::Configuration::DirectoryDirectives
  include(::Reek::Configuration::ConfigurationValidator)

  def add(directory_config); end
  def directive_for(source_via); end

  private

  def best_match_for(source_base_dir); end
  def error_message_for_invalid_smell_type(klass); end
  def glob_to_regexp(glob); end
  def match?(source_base_dir, pathname); end
end

module Reek::Configuration::ExcludedPaths
  include(::Reek::Configuration::ConfigurationValidator)

  def add(paths); end
end

class Reek::Configuration::SchemaValidator
  def initialize(configuration); end

  def validate; end

  private

  def error_message(errors); end
end

Reek::Configuration::SchemaValidator::SCHEMA_FILE_PATH = T.let(T.unsafe(nil), String)

module Reek::Context
end

class Reek::Context::AttributeContext < ::Reek::Context::CodeContext
  def initialize(exp, send_expression); end

  def apply_current_visibility(current_visibility); end
  def full_comment; end
  def instance_method?; end
  def visibility; end
  def visibility=(_arg0); end

  private

  def send_expression; end
end

class Reek::Context::ClassContext < ::Reek::Context::ModuleContext
end

class Reek::Context::CodeContext
  include(::Enumerable)
  extend(::Forwardable)

  def initialize(exp); end

  def append_child_context(child); end
  def apply_current_visibility(_current_visibility); end
  def children; end
  def config_for(detector_class); end
  def each(&block); end
  def exp; end
  def full_name; end
  def instance_method?; end
  def local_nodes(type, ignored = T.unsafe(nil), &blk); end
  def matches?(candidates); end
  def name(*args, &block); end
  def number_of_statements; end
  def parent; end
  def record_call_to(exp); end
  def record_use_of_self; end
  def register_with_parent(parent); end
  def singleton_method?; end
  def statement_counter; end
  def type(*args, &block); end

  private

  def configuration_via_code_commment; end
  def full_comment; end
  def parent_config_for(detector_class); end
  def refs; end
end

class Reek::Context::GhostContext < ::Reek::Context::ModuleContext
  def append_child_context(child); end
  def attribute_context_class; end
  def children; end
  def method_context_class; end
  def record_use_of_self; end
  def register_with_parent(parent); end
  def statement_counter; end
  def track_visibility(visibility, names); end
end

class Reek::Context::MethodContext < ::Reek::Context::CodeContext
  def initialize(exp, parent_exp); end

  def apply_current_visibility(current_visibility); end
  def default_assignments; end
  def full_comment; end
  def instance_method?; end
  def method_context_class; end
  def module_function?; end
  def non_public_visibility?; end
  def references_self?; end
  def refs; end
  def singleton_method?; end
  def unused_params; end
  def uses_param?(param); end
  def uses_super_with_implicit_arguments?; end
  def visibility; end
  def visibility=(_arg0); end

  private

  def parent_exp; end
end

class Reek::Context::ModuleContext < ::Reek::Context::CodeContext
  def initialize(exp); end

  def append_child_context(child); end
  def attribute_context_class; end
  def defined_instance_methods(visibility: T.unsafe(nil)); end
  def descriptively_commented?; end
  def instance_method_calls; end
  def method_context_class; end
  def namespace_module?; end
  def node_instance_methods; end
  def track_visibility(visibility, names); end
  def visibility_tracker; end

  private

  def instance_method_children; end
  def singleton_method_children; end
end

Reek::Context::ModuleContext::CONSTANT_SEXP_TYPES = T.let(T.unsafe(nil), Array)

class Reek::Context::RefinementContext < ::Reek::Context::ModuleContext
  def full_name; end
end

class Reek::Context::RootContext < ::Reek::Context::CodeContext
  def full_name; end
  def method_context_class; end
  def type; end
end

class Reek::Context::SendContext < ::Reek::Context::CodeContext
  def initialize(exp, name); end

  def name; end
end

class Reek::Context::SingletonAttributeContext < ::Reek::Context::AttributeContext
  def instance_method?; end
end

class Reek::Context::SingletonMethodContext < ::Reek::Context::MethodContext
  def apply_current_visibility(current_visibility); end
  def defined_as_instance_method?; end
  def instance_method?; end
  def module_function?; end
  def singleton_method?; end
end

class Reek::Context::StatementCounter
  def initialize; end

  def decrease_by(number); end
  def increase_by(sexp); end
  def value; end

  private

  def value=(_arg0); end
end

class Reek::Context::VisibilityTracker
  def initialize; end

  def apply_visibility(context); end
  def track_singleton_visibility(children:, visibility:, names:); end
  def track_visibility(children:, visibility:, names:); end

  private

  def tracked_visibility; end
  def tracked_visibility=(_arg0); end
end

Reek::Context::VisibilityTracker::VISIBILITY_MAP = T.let(T.unsafe(nil), Hash)

Reek::Context::VisibilityTracker::VISIBILITY_MODIFIERS = T.let(T.unsafe(nil), Array)

class Reek::ContextBuilder
  def initialize(syntax_tree); end

  def context_tree; end

  private

  def append_new_context(klass, *args); end
  def build(exp, parent_exp = T.unsafe(nil)); end
  def context_processor_exists?(name); end
  def current_context; end
  def current_context=(_arg0); end
  def decrease_statement_count; end
  def exp; end
  def handle_refinement_block(exp); end
  def handle_send_for_methods(exp); end
  def handle_send_for_modules(exp); end
  def increase_statement_count_by(sexp); end
  def inside_new_context(klass, *args); end
  def process(exp); end
  def process_begin(exp, _parent); end
  def process_block(exp, _parent); end
  def process_case(exp, _parent); end
  def process_casgn(exp, parent); end
  def process_class(exp, _parent); end
  def process_def(exp, parent); end
  def process_defs(exp, parent); end
  def process_for(exp, _parent); end
  def process_if(exp, _parent); end
  def process_ivar(exp, _parent); end
  def process_ivasgn(exp, _parent); end
  def process_kwbegin(exp, _parent); end
  def process_module(exp, _parent); end
  def process_op_asgn(exp, _parent); end
  def process_resbody(exp, _parent); end
  def process_rescue(exp, _parent); end
  def process_sclass(exp, _parent); end
  def process_self(_exp, _parent); end
  def process_send(exp, _parent); end
  def process_super(exp, _parent); end
  def process_until(exp, _parent); end
  def process_when(exp, _parent); end
  def process_while(exp, _parent); end
  def process_zsuper(_exp, _parent); end
  def register_attributes(exp); end
end

Reek::DEFAULT_CONFIGURATION_FILE_NAME = T.let(T.unsafe(nil), String)

Reek::DEFAULT_SMELL_CONFIGURATION = T.let(T.unsafe(nil), String)

Reek::DETECTORS_KEY = T.let(T.unsafe(nil), String)

Reek::DIRECTORIES_KEY = T.let(T.unsafe(nil), String)

class Reek::DetectorRepository
  def initialize(smell_types: T.unsafe(nil), configuration: T.unsafe(nil)); end

  def examine(context); end

  private

  def configuration; end
  def configuration_for(klass); end
  def smell_detectors_for(type); end
  def smell_types; end

  class << self
    def available_detector_names; end
    def eligible_smell_types(filter_by_smells = T.unsafe(nil)); end
    def smell_types; end
  end
end

module Reek::DocumentationLink

  private

  def build(subject); end
  def name_to_param(name); end

  class << self
    def build(subject); end
    def name_to_param(name); end
  end
end

Reek::DocumentationLink::HELP_LINK_TEMPLATE = T.let(T.unsafe(nil), String)

Reek::EXCLUDE_PATHS_KEY = T.let(T.unsafe(nil), String)

module Reek::Errors
end

class Reek::Errors::BadDetectorConfigurationKeyInCommentError < ::Reek::Errors::BaseError
  def initialize(detector_name:, offensive_keys:, source:, line:, original_comment:); end
end

Reek::Errors::BadDetectorConfigurationKeyInCommentError::UNKNOWN_SMELL_DETECTOR_MESSAGE = T.let(T.unsafe(nil), String)

class Reek::Errors::BadDetectorInCommentError < ::Reek::Errors::BaseError
  def initialize(detector_name:, source:, line:, original_comment:); end
end

Reek::Errors::BadDetectorInCommentError::UNKNOWN_SMELL_DETECTOR_MESSAGE = T.let(T.unsafe(nil), String)

class Reek::Errors::BaseError < ::RuntimeError
  def long_message; end
end

class Reek::Errors::ConfigFileError < ::Reek::Errors::BaseError
end

class Reek::Errors::EncodingError < ::Reek::Errors::BaseError
  def initialize(origin:); end

  def long_message; end
end

Reek::Errors::EncodingError::LONG_TEMPLATE = T.let(T.unsafe(nil), String)

Reek::Errors::EncodingError::TEMPLATE = T.let(T.unsafe(nil), String)

class Reek::Errors::GarbageDetectorConfigurationInCommentError < ::Reek::Errors::BaseError
  def initialize(detector_name:, source:, line:, original_comment:); end
end

Reek::Errors::GarbageDetectorConfigurationInCommentError::BAD_DETECTOR_CONFIGURATION_MESSAGE = T.let(T.unsafe(nil), String)

class Reek::Errors::IncomprehensibleSourceError < ::Reek::Errors::BaseError
  def initialize(origin:); end

  def long_message; end
end

Reek::Errors::IncomprehensibleSourceError::LONG_TEMPLATE = T.let(T.unsafe(nil), String)

Reek::Errors::IncomprehensibleSourceError::TEMPLATE = T.let(T.unsafe(nil), String)

class Reek::Errors::LegacyCommentSeparatorError < ::Reek::Errors::BaseError
  def initialize(source:, line:, original_comment:); end
end

Reek::Errors::LegacyCommentSeparatorError::MESSAGE = T.let(T.unsafe(nil), String)

class Reek::Errors::SyntaxError < ::Reek::Errors::BaseError
  def initialize(origin:); end

  def long_message; end
end

Reek::Errors::SyntaxError::LONG_TEMPLATE = T.let(T.unsafe(nil), String)

Reek::Errors::SyntaxError::TEMPLATE = T.let(T.unsafe(nil), String)

class Reek::Examiner
  def initialize(source, filter_by_smells: T.unsafe(nil), configuration: T.unsafe(nil), detector_repository_class: T.unsafe(nil), error_handler: T.unsafe(nil)); end

  def origin; end
  def smells; end
  def smells_count; end
  def smelly?; end

  private

  def detector_repository; end
  def examine_tree; end
  def run; end
  def source; end
  def syntax_tree; end
  def wrap_exceptions; end
end

class Reek::Examiner::NullHandler
  def handle(_exception); end
end

class Reek::Overrides
  def initialize(hash); end

  def for_context(context); end

  private

  def hash; end
end

module Reek::Report
  class << self
    def heading_formatter(heading_format); end
    def location_formatter(location_format); end
    def progress_formatter(progress_format); end
    def report_class(report_format); end
    def warning_formatter_class(warning_format); end
  end
end

class Reek::Report::BaseReport
  def initialize(heading_formatter: T.unsafe(nil), sort_by_issue_count: T.unsafe(nil), warning_formatter: T.unsafe(nil), progress_formatter: T.unsafe(nil)); end

  def add_examiner(examiner); end
  def show; end
  def smells; end
  def smells?; end

  protected

  def total_smell_count; end
  def total_smell_count=(_arg0); end

  private

  def examiners; end
  def heading_formatter; end
  def progress_formatter; end
  def sort_by_issue_count; end
  def warning_formatter; end
end

Reek::Report::BaseReport::NO_WARNINGS_COLOR = T.let(T.unsafe(nil), Symbol)

Reek::Report::BaseReport::WARNINGS_COLOR = T.let(T.unsafe(nil), Symbol)

module Reek::Report::BlankLocationFormatter

  private

  def format(_warning); end

  class << self
    def format(_warning); end
  end
end

module Reek::Report::DefaultLocationFormatter

  private

  def format(warning); end

  class << self
    def format(warning); end
  end
end

class Reek::Report::DocumentationLinkWarningFormatter < ::Reek::Report::SimpleWarningFormatter
  def format(warning); end
end

Reek::Report::HEADING_FORMATTERS = T.let(T.unsafe(nil), Hash)

class Reek::Report::HTMLReport < ::Reek::Report::BaseReport
  def show; end
end

class Reek::Report::HeadingFormatterBase
  def header(examiner); end
  def show_header?(_examiner); end

  private

  def formatted_header(examiner); end
end

class Reek::Report::JSONReport < ::Reek::Report::BaseReport
  def show(out = T.unsafe(nil)); end
end

Reek::Report::LOCATION_FORMATTERS = T.let(T.unsafe(nil), Hash)

Reek::Report::PROGRESS_FORMATTERS = T.let(T.unsafe(nil), Hash)

module Reek::Report::ProgressFormatter
end

class Reek::Report::ProgressFormatter::Base
  def initialize(sources_count); end

  def footer; end
  def header; end
  def progress(_examiner); end
  def sources_count; end
end

class Reek::Report::ProgressFormatter::Dots < ::Reek::Report::ProgressFormatter::Base
  def footer; end
  def header; end
  def progress(examiner); end

  private

  def display_clean; end
  def display_smelly; end
end

Reek::Report::ProgressFormatter::Dots::NO_WARNINGS_COLOR = T.let(T.unsafe(nil), Symbol)

Reek::Report::ProgressFormatter::Dots::WARNINGS_COLOR = T.let(T.unsafe(nil), Symbol)

class Reek::Report::ProgressFormatter::Quiet < ::Reek::Report::ProgressFormatter::Base
  def footer; end
  def header; end
  def progress(_examiner); end
end

class Reek::Report::QuietHeadingFormatter < ::Reek::Report::HeadingFormatterBase
  def show_header?(examiner); end
end

Reek::Report::REPORT_CLASSES = T.let(T.unsafe(nil), Hash)

class Reek::Report::SimpleWarningFormatter
  def initialize(location_formatter: T.unsafe(nil)); end

  def format(warning); end
  def format_list(warnings); end

  private

  def location_formatter; end
end

module Reek::Report::SingleLineLocationFormatter

  private

  def format(warning); end

  class << self
    def format(warning); end
  end
end

class Reek::Report::TextReport < ::Reek::Report::BaseReport
  def initialize(**args); end

  def add_examiner(examiner); end
  def show; end

  private

  def display_summary; end
  def display_total_smell_count; end
  def smell_summaries; end
  def sort_examiners; end
  def summarize_single_examiner(examiner); end
  def total_smell_count_message; end
end

class Reek::Report::VerboseHeadingFormatter < ::Reek::Report::HeadingFormatterBase
  def show_header?(_examiner); end
end

Reek::Report::WARNING_FORMATTER_CLASSES = T.let(T.unsafe(nil), Hash)

class Reek::Report::XMLReport < ::Reek::Report::BaseReport
  def show; end

  private

  def checkstyle; end
  def document; end
  def error(smell, line); end
  def file(name, smells); end
end

class Reek::Report::YAMLReport < ::Reek::Report::BaseReport
  def show(out = T.unsafe(nil)); end
end

class Reek::SmellConfiguration
  def initialize(hash); end

  def enabled?; end
  def merge(new_options); end
  def overrides_for(context); end
  def value(key, context); end

  private

  def options; end
end

Reek::SmellConfiguration::ENABLED_KEY = T.let(T.unsafe(nil), String)

Reek::SmellConfiguration::OVERRIDES_KEY = T.let(T.unsafe(nil), String)

module Reek::SmellDetectors
end

class Reek::SmellDetectors::Attribute < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def attributes_in_context; end

  class << self
    def contexts; end
  end
end

class Reek::SmellDetectors::BaseDetector
  def initialize(configuration: T.unsafe(nil), context: T.unsafe(nil)); end

  def config; end
  def run; end
  def smell_type; end

  private

  def config_for(ctx); end
  def context; end
  def enabled?; end
  def exception?; end
  def expression; end
  def smell_warning(**options); end
  def source_line; end
  def value(key, ctx); end

  class << self
    def configuration_keys; end
    def contexts; end
    def default_config; end
    def descendants; end
    def inherited(subclass); end
    def smell_type; end
    def to_detector(detector_name); end
    def todo_configuration_for(smells); end
  end
end

Reek::SmellDetectors::BaseDetector::DEFAULT_EXCLUDE_SET = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::BaseDetector::EXCLUDE_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::BooleanParameter < ::Reek::SmellDetectors::BaseDetector
  def sniff; end
end

Reek::SmellDetectors::BooleanParameter::BOOLEAN_VALUES = T.let(T.unsafe(nil), Array)

class Reek::SmellDetectors::ClassVariable < ::Reek::SmellDetectors::BaseDetector
  def class_variables_in_context; end
  def sniff; end

  class << self
    def contexts; end
  end
end

class Reek::SmellDetectors::ControlParameter < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def control_parameters; end
  def find_matches(parameter); end
  def potential_parameters; end
end

module Reek::SmellDetectors::ControlParameterHelpers
end

class Reek::SmellDetectors::ControlParameterHelpers::CallInConditionFinder
  def initialize(node, parameter); end

  def uses_param_in_call_in_condition?; end

  private

  def call_involving_param?(call_node); end
  def comparison_call?(call_node); end
  def node; end
  def parameter; end
  def regular_call_involving_param?(call_node); end
end

Reek::SmellDetectors::ControlParameterHelpers::CallInConditionFinder::COMPARISON_METHOD_NAMES = T.let(T.unsafe(nil), Array)

class Reek::SmellDetectors::ControlParameterHelpers::Candidate
  def initialize(parameter, occurences); end

  def lines; end
  def name; end
  def smells?; end

  private

  def occurences; end
  def parameter; end
end

class Reek::SmellDetectors::ControlParameterHelpers::ControlParameterFinder
  def initialize(node, parameter); end

  def find_matches; end
  def legitimate_uses?; end

  private

  def conditional_nodes; end
  def nested_finders; end
  def node; end
  def parameter; end
  def parameter_used_in_body?; end
  def uses_of_param_in_condition; end
end

Reek::SmellDetectors::ControlParameterHelpers::ControlParameterFinder::CONDITIONAL_NODE_TYPES = T.let(T.unsafe(nil), Array)

class Reek::SmellDetectors::DataClump < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def candidate_clumps; end
  def candidate_methods; end
  def clumps; end
  def common_argument_names_for(methods); end
  def max_copies; end
  def methods_containing_clump(clump); end
  def min_clump_size; end

  class << self
    def contexts; end
    def default_config; end
    def print_clump(clump); end
  end
end

Reek::SmellDetectors::DataClump::DEFAULT_MAX_COPIES = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::DataClump::DEFAULT_MIN_CLUMP_SIZE = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::DataClump::MAX_COPIES_KEY = T.let(T.unsafe(nil), String)

Reek::SmellDetectors::DataClump::MIN_CLUMP_SIZE_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::DuplicateMethodCall < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def allow_calls; end
  def max_allowed_calls; end

  class << self
    def default_config; end
  end
end

Reek::SmellDetectors::DuplicateMethodCall::ALLOW_CALLS_KEY = T.let(T.unsafe(nil), String)

Reek::SmellDetectors::DuplicateMethodCall::DEFAULT_ALLOW_CALLS = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::DuplicateMethodCall::DEFAULT_MAX_CALLS = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::DuplicateMethodCall::MAX_ALLOWED_CALLS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::FeatureEnvy < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def envious_receivers; end
  def refs; end
end

class Reek::SmellDetectors::InstanceVariableAssumption < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def build_smell_warning(assumption); end
  def method_expressions; end
  def variables_from_context; end
  def variables_from_initialize; end

  class << self
    def contexts; end
  end
end

class Reek::SmellDetectors::IrresponsibleModule < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def descriptive_context?; end

  class << self
    def contexts; end
  end
end

class Reek::SmellDetectors::LongParameterList < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def max_allowed_params; end

  class << self
    def default_config; end
  end
end

Reek::SmellDetectors::LongParameterList::DEFAULT_MAX_ALLOWED_PARAMS = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::LongParameterList::MAX_ALLOWED_PARAMS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::LongYieldList < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def max_allowed_params; end

  class << self
    def default_config; end
  end
end

Reek::SmellDetectors::LongYieldList::DEFAULT_MAX_ALLOWED_PARAMS = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::LongYieldList::MAX_ALLOWED_PARAMS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::ManualDispatch < ::Reek::SmellDetectors::BaseDetector
  def sniff; end
end

Reek::SmellDetectors::ManualDispatch::MESSAGE = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::MissingSafeMethod < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def ignore_method?(method_node); end
  def ignore_method_names; end
  def missing_safe_method?(method_sexp); end
  def version_without_bang_exists?(method_sexp); end

  class << self
    def contexts; end
  end
end

class Reek::SmellDetectors::ModuleInitialize < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  class << self
    def contexts; end
  end
end

class Reek::SmellDetectors::NestedIterators < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def find_candidates; end
  def find_violations; end
  def ignore_iterators; end
  def ignored_iterator?(exp); end
  def increment_depth(iterator, depth); end
  def max_allowed_nesting; end
  def scout(exp:, depth:); end

  class << self
    def default_config; end
  end
end

Reek::SmellDetectors::NestedIterators::DEFAULT_IGNORE_ITERATORS = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::NestedIterators::DEFAULT_MAX_ALLOWED_NESTING = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::NestedIterators::IGNORE_ITERATORS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::NestedIterators::Iterator < ::Struct
  def depth; end
  def depth=(_); end
  def exp; end
  def exp=(_); end
  def line; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

Reek::SmellDetectors::NestedIterators::MAX_ALLOWED_NESTING_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::NilCheck < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def detect_nodes; end
end

module Reek::SmellDetectors::NilCheck::NilCallNodeDetector

  private

  def comparison_call?(call); end
  def comparison_methods; end
  def detect(node); end
  def involves_nil?(call); end
  def nil_comparison?(call); end
  def nil_query?(call); end

  class << self
    def comparison_call?(call); end
    def comparison_methods; end
    def detect(node); end
    def involves_nil?(call); end
    def nil_comparison?(call); end
    def nil_query?(call); end
  end
end

module Reek::SmellDetectors::NilCheck::NilWhenNodeDetector

  private

  def detect(node); end

  class << self
    def detect(node); end
  end
end

class Reek::SmellDetectors::RepeatedConditional < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def conditional_counts; end
  def max_identical_ifs; end

  class << self
    def contexts; end
    def default_config; end
  end
end

Reek::SmellDetectors::RepeatedConditional::BLOCK_GIVEN_CONDITION = T.let(T.unsafe(nil), Parser::AST::Node)

Reek::SmellDetectors::RepeatedConditional::DEFAULT_MAX_IFS = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::RepeatedConditional::MAX_IDENTICAL_IFS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::SubclassedFromCoreClass < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def build_smell_warning(ancestor_name); end
  def sniff_superclass(superclass_name); end

  class << self
    def contexts; end
  end
end

Reek::SmellDetectors::SubclassedFromCoreClass::CORE_CLASSES = T.let(T.unsafe(nil), Array)

class Reek::SmellDetectors::TooManyConstants < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def build_smell_warning(count); end
  def max_allowed_constants; end

  class << self
    def contexts; end
    def default_config; end
  end
end

Reek::SmellDetectors::TooManyConstants::DEFAULT_MAX_CONSTANTS = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::TooManyConstants::IGNORED_NODES = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::TooManyConstants::MAX_ALLOWED_CONSTANTS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::TooManyInstanceVariables < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def max_allowed_ivars; end

  class << self
    def contexts; end
    def default_config; end
  end
end

Reek::SmellDetectors::TooManyInstanceVariables::DEFAULT_MAX_IVARS = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::TooManyInstanceVariables::MAX_ALLOWED_IVARS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::TooManyMethods < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def max_allowed_methods; end

  class << self
    def contexts; end
    def default_config; end
  end
end

Reek::SmellDetectors::TooManyMethods::DEFAULT_MAX_METHODS = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::TooManyMethods::MAX_ALLOWED_METHODS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::TooManyStatements < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def max_allowed_statements; end

  class << self
    def default_config; end
  end
end

Reek::SmellDetectors::TooManyStatements::DEFAULT_MAX_STATEMENTS = T.let(T.unsafe(nil), Integer)

Reek::SmellDetectors::TooManyStatements::MAX_ALLOWED_STATEMENTS_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::UncommunicativeMethodName < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def accept_patterns; end
  def acceptable_name?(name); end
  def reject_patterns; end

  class << self
    def default_config; end
  end
end

Reek::SmellDetectors::UncommunicativeMethodName::ACCEPT_KEY = T.let(T.unsafe(nil), String)

Reek::SmellDetectors::UncommunicativeMethodName::DEFAULT_ACCEPT_PATTERNS = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::UncommunicativeMethodName::DEFAULT_REJECT_PATTERNS = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::UncommunicativeMethodName::REJECT_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::UncommunicativeModuleName < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def accept_patterns; end
  def acceptable_name?(module_name:, fully_qualified_name:); end
  def reject_patterns; end

  class << self
    def contexts; end
    def default_config; end
  end
end

Reek::SmellDetectors::UncommunicativeModuleName::ACCEPT_KEY = T.let(T.unsafe(nil), String)

Reek::SmellDetectors::UncommunicativeModuleName::DEFAULT_ACCEPT_PATTERNS = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::UncommunicativeModuleName::DEFAULT_REJECT_PATTERNS = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::UncommunicativeModuleName::REJECT_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::UncommunicativeParameterName < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def accept_patterns; end
  def acceptable_name?(name); end
  def reject_patterns; end
  def uncommunicative_parameter?(parameter); end

  class << self
    def default_config; end
  end
end

Reek::SmellDetectors::UncommunicativeParameterName::ACCEPT_KEY = T.let(T.unsafe(nil), String)

Reek::SmellDetectors::UncommunicativeParameterName::DEFAULT_ACCEPT_PATTERNS = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::UncommunicativeParameterName::DEFAULT_REJECT_PATTERNS = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::UncommunicativeParameterName::REJECT_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::UncommunicativeVariableName < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def accept_names; end
  def acceptable_name?(name); end
  def find_assignment_variable_names(accumulator); end
  def find_block_argument_variable_names(accumulator); end
  def record_variable_name(exp, symbol, accumulator); end
  def recursively_record_variable_names(accumulator, exp); end
  def reject_names; end
  def uncommunicative_variable_name?(name); end
  def variable_names; end

  class << self
    def contexts; end
    def default_config; end
  end
end

Reek::SmellDetectors::UncommunicativeVariableName::ACCEPT_KEY = T.let(T.unsafe(nil), String)

Reek::SmellDetectors::UncommunicativeVariableName::DEFAULT_ACCEPT_SET = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::UncommunicativeVariableName::DEFAULT_REJECT_SET = T.let(T.unsafe(nil), Array)

Reek::SmellDetectors::UncommunicativeVariableName::REJECT_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellDetectors::UnusedParameters < ::Reek::SmellDetectors::BaseDetector
  def sniff; end
end

class Reek::SmellDetectors::UnusedPrivateMethod < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def hits; end
  def ignore_method?(method); end
  def unused_private_methods; end

  class << self
    def contexts; end
    def default_config; end
  end
end

class Reek::SmellDetectors::UnusedPrivateMethod::Hit
  def initialize(context); end

  def line; end
  def name; end
end

class Reek::SmellDetectors::UtilityFunction < ::Reek::SmellDetectors::BaseDetector
  def sniff; end

  private

  def ignore_method?; end
  def num_helper_methods; end

  class << self
    def contexts; end
    def default_config; end
  end
end

Reek::SmellDetectors::UtilityFunction::PUBLIC_METHODS_ONLY_KEY = T.let(T.unsafe(nil), String)

class Reek::SmellWarning
  include(::Comparable)
  extend(::Forwardable)

  def initialize(smell_type, lines:, message:, source:, context: T.unsafe(nil), parameters: T.unsafe(nil)); end

  def <=>(other); end
  def base_message; end
  def context; end
  def eql?(other); end
  def explanatory_link; end
  def hash; end
  def lines; end
  def message; end
  def parameters; end
  def smell_type; end
  def source; end
  def to_hash; end
  def yaml_hash; end

  protected

  def identifying_values; end

  private

  def base_hash; end
end

module Reek::Source
end

class Reek::Source::SourceCode
  def initialize(source:, origin: T.unsafe(nil), parser: T.unsafe(nil)); end

  def origin; end
  def syntax_tree; end

  private

  def code; end
  def parse; end
  def parser; end
  def source; end

  class << self
    def default_parser; end
    def from(source, origin: T.unsafe(nil)); end
  end
end

Reek::Source::SourceCode::IO_IDENTIFIER = T.let(T.unsafe(nil), String)

Reek::Source::SourceCode::STRING_IDENTIFIER = T.let(T.unsafe(nil), String)

class Reek::TreeDresser
  def initialize(klass_map: T.unsafe(nil)); end

  def dress(sexp, comment_map); end

  private

  def klass_map; end
end

module Reek::Version
end

Reek::Version::STRING = T.let(T.unsafe(nil), String)
